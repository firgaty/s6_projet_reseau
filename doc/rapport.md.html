     <meta charset="utf-8" emacsmode="-*- markdown -*-"><link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/apidoc.css?">

                          **Projet de programmation rÃ©seau**
                          miaouchat : Â« Groupe de discussion par inondation fiable Â»
                          __FÃ©lix Desmaretz__ + __Louis Gavalda__

Nous avons implementÃ© le protocole spÃ©cifiÃ© dans le [sujet](https://www.irif.fr/~jch/enseignement/prog-reseau/projet.pdf) proposÃ© par Juliusz Chroboczek afin de crÃ©er un chat P2P (ou _groupe de discussion pair Ã  pair_).

Ce rapport rend compte des choix qui ont Ã©tÃ© faits.

## Utilisation

### Compilation (tl;dr: `make && ./miaouchat`)

Il faut bien sÃ»r le compiler avant de pouvoir le lancer. Les commandes suivantes sont Ã  exÃ©cuter Ã  la racine du projet et ont les effets suivants :

- `make` gÃ©nÃ¨re un fichier exÃ©cutable nommÃ© `miaouchat` : câ€™est notre programme, fraÃ®chement compilÃ©, bien jouÃ© ! Vous pouvez ensuite le lancer en tapant `./miaouchat` dans votre terminal.
- `doxygen Doxyfile` gÃ©nÃ¨re automatiquement la documentation (que ce compte rendu vient complÃ©ter) Ã  partir de commentaires prÃ©sents directement dans les sources. Ensuite, la commande `./manual` vous permet dâ€™ouvrir ladite documentation dans un nouvel onglet du navigateur.

### Interface graphique (tl;dr: on peut discuter avec les autres gens)

Lorsque __miaouchat__ se lance, une fenÃªtre apparaÃ®t. Rien dâ€™extravagant : nous avons voulu nous rapprocher du style minimaliste des interfaces [IRC](https://fr.wikipedia.org/wiki/Internet_Relay_Chat) dâ€™antan, au sein desquelles un discussion se voyait rÃ©duite Ã  lâ€™essentiel.

En haut Ã  droite sâ€™affiche le nombre de pairs/voisins symÃ©triques auxquels notre programme est connectÃ©. Au milieu, la plus grande partie de la fenÃªtre contient la liste des messages reÃ§us depuis le dÃ©marrage. Pour discuter, câ€™est enfantin, Ã§a se passerait mÃªme dâ€™instructions : il suffit dâ€™Ã©crire un message dans le champ de texte (en bas de la fenÃªtre) puis dâ€™appuyer sur EntrÃ©e pour lâ€™envoyer.

Lâ€™heure dâ€™envoi est spÃ©cifiÃ©e avant chaque message, ainsi que -- normalement -- le pseudo de lâ€™Ã©metteur. On a donc un affichage qui ressemble plus ou moins Ã  :

~~~
[14:26:44] <bob> mais câ€™est top !!
[14:26:55] <alice> comme tu dis ;-)
[14:27:02] <bob> au top
[14:27:06] <bob> miaou ğŸˆ
[14:27:18] <alice> wouf ğŸ•ğŸ•
[14:27:25] <bob> ...
~~~


 Des messages Ã  propos de lâ€™exÃ©cution du programme peuvent Ã©galement sâ€™afficher en orange.

## Sous le capot

### ParticularitÃ©s du projet (tl;dr: protocole bien pensÃ©, pour lâ€™usage)

On peut remercier lâ€™auteur du sujet dâ€™avoir rÃ©flÃ©chi sÃ©rieusement Ã  son protocole. La spÃ©cification y est relativement prÃ©cise, et des conseils sont mÃªmes fournis afin de nous guider dans lâ€™implÃ©mentation.

Il sâ€™agit dâ€˜un protocole pair Ã  pair dans lequels les messages sont Â« inondÃ©s Â» sur le rÃ©seau. Chaque membre du rÃ©seau reÃ§oit lâ€™intÃ©gralitÃ© des messages, quâ€™ils sâ€™adressent Ã  lui ou non. (Un membre, ou nÅ“ud, est un logiciel qui exÃ©cute une implÃ©mentation du protocole, et qui forme un rÃ©seau avec lâ€™ensemble des autres membres avec qui il est Â« connectÃ© Â».)

Lorsquâ€™un message adressÃ© Ã  un rÃ©cepteur prÃ©cis est Ã©mis, ce message est transmis Ã  chacun des voisins de lâ€™Ã©metteur via __UDP__. De maniÃ¨re rÃ©cursive, chacun transmet (_broadcast_) Ã  son tour le message jusquâ€™Ã  quâ€™il ait Ã©tÃ© reÃ§u par tous les membres du rÃ©seau.

Une telle maniÃ¨re de procÃ©der induit Ã©videmment des limitations, et câ€™est pourquoi on se contente dâ€™utiliser ce protocole pour Ã©changer des messages textuels. Sans mÃªme parler de fragmentation, si un message/fichier lourd devait sâ€™Ã©changer entre deux utilisateurs, il se verrait propagÃ© sur tout le rÃ©seau, ce qui constituerait un terrible gaspillage de bande passante (Ã©tant donnÃ© que le message/fichier ne sâ€™adresse quâ€™Ã  une personne).

Notre programme, dans sa partie rÃ©seau, sâ€™appuie exclusivement sur __UDP__ qui, comme vous le savez, est dÃ©pourvu de contrÃ´le dâ€™erreurs (rÃ©Ã©mission, fragmentation, etc.). Pour construire un vÃ©ritable groupe de discussion, il faut donc gÃ©rer tout un tas de choses (Â« Ã  qui est destinÃ© tel ou tel message ? Â» ; Â« qui est autorisÃ© Ã  mâ€™envoyer un message ? Â»).

Les donnÃ©es traitÃ©es par lâ€™application sont Ã©changÃ©es sous forme de __TLV__ (pour _Type, Length, Value_) dont les formats sont prÃ©cisÃ©ment dÃ©finis.


### C pas sorcier (tl;dr: aÃ¯e câ€™est bas niveau)

Il Ã©tait imposÃ© dâ€™Ã©crire le programme en C. Chouette language. Pour de nombreuses raisons, il est fort adaptÃ© Ã  lâ€™apprentissage de la programmation rÃ©seau (on se trouve Ã  Â« bas niveau Â»).

Du point de vue de son architecture, notre programme est simple, il se contente de coller au protocole. Ceci dit, en C, puisquâ€™il faut gÃ©rer la mÃ©moire, etc., il est pratique de crÃ©er tout un tas de types de donnÃ©es, de routines, pour se simplifier la vie dans la suite du dÃ©veloppement. Les concepts Ã  manipuler ont beau Ãªtre simples, la logique Ã©lÃ©mentaire, il nous a fallu Ã©crire plusieurs milliers de lignes de code ; lÃ  oÃ¹ une implÃ©mentation en Python (par exemple) aurait requis tout au plus quelques centaines de lignes.

Pas de souci avec Ã§a, hein, au contraire, Ã§a nous fait des choses Ã  dÃ©tailler dans ce compte rendu. Mais tout de mÃªme : coder en C prend du temps.


### DÃ©cisions prises (tl;dr: interface en GTK)

**miaouchat**, câ€™est le nom que nous avons donnÃ© Ã  notre logiciel.

Par contre, nous tenions Ã  avoir une vraie interface graphique, bien propre, afin que __miaouchat__ ne consiste pas seulement en une _proof of concept_ mais soit vraiment agrÃ©able Ã  utiliser pour des personnes qui nâ€™ont pas lâ€™habitude du terminal.

Câ€™est GTK qui nous a paru Ãªtre le meilleur choix, car GTK est une librairie...

- Ã©crite en C, et sâ€™utilise donc nativement dans ce langage ;
- Ã©prouvÃ©e (elle existe depuis plus de vingt ans) ; on dispose de suffisamment dâ€™exemples pour se dÃ©patouiller et obtenir ce que lâ€™on souhaite, contrairement Ã  la plupart des autres solutions exotiques ;
- installÃ©e presque partout ;
- qui permet dâ€™obtenir un rÃ©sultat satisfaisant -- en terme dâ€™esthÃ©tique -- assez rapidement.


### Beaucoup de fichiers (tl;dr: câ€™est bien rangÃ©)

Fichier (.h/.c) | Contient | Notes
----------------|----------|------
dllist | fonctions de manipulation de listes doublement chaÃ®nÃ©es de type `dllist_t`. ||
map | sources de la hashmap. | auteur : [rxi, sur Github](https://github.com/rxi/map) |
msg | mÃ©thodes de manipulation et transformations des TLV et messages. ||
test | tests Ã©crits durant le dÃ©veloppement. ||
types | types non standards, afin de les centraliser et d'Ã©viter les conflits d'importation. ||
neighbour | implÃ©mentent les diffÃ©rentes listes de voisins et leur manipulations. ||

## Logique de fonctionnement

### Relation entre voisins

![](projet/img/voisins_dia.png)


### RÃ©ception dâ€™un message

![](projet/img/reception_data_dia.png)

<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'medium'};</script>
<!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
