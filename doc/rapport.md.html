<meta charset="utf-8" emacsmode="-*- markdown -*-">

                        **Projet de programmation rÃ©seau**
                        miaouchat : Â« Groupe de discussion par inondation fiable Â»
                        __FÃ©lix Desmaretz__ + __Louis Gavalda__

Nous avons implementÃ© le protocole spÃ©cifiÃ© dans le [sujet](https://www.irif.fr/~jch/enseignement/prog-reseau/projet.pdf) proposÃ© par Juliusz Chroboczek afin de crÃ©er un groupe de discussion pair Ã  pair (ou _chat P2P_, Ã§a sonne mieux).

Ce rapport rend compte des choix qui ont Ã©tÃ© faits et dÃ©taille la logique de notre implÃ©mentation.

## Utilisation

### Compilation (tl;dr: `make && ./miaouchat`)

Il faut bien sÃ»r compiler le programme avant de pouvoir le lancer. Les commandes suivantes sont Ã  exÃ©cuter Ã  la racine du projet et ont les effets suivants :

- `make` gÃ©nÃ¨re un fichier exÃ©cutable nommÃ© `miaouchat` : câ€™est notre programme, fraÃ®chement compilÃ©, bien jouÃ© ! Vous pouvez ensuite le lancer en tapant `./miaouchat` dans votre terminal.
- `doxygen Doxyfile` gÃ©nÃ¨re automatiquement la documentation (que ce compte rendu vient complÃ©ter) Ã  partir de commentaires prÃ©sents directement dans les sources. Ensuite, la commande `./manual` vous permet dâ€™ouvrir ladite documentation dans un nouvel onglet de votre navigateur.

### Interface graphique (tl;dr: on peut discuter avec les autres gens)

Lorsque __miaouchat__ se lance, une fenÃªtre apparaÃ®t. Rien dâ€™extravagant : nous avons voulu nous rapprocher du style minimaliste des interfaces [IRC](https://fr.wikipedia.org/wiki/Internet_Relay_Chat) dâ€™antan, dans lesquelles une discussion est rÃ©duite Ã  lâ€™essentiel.

En haut Ã  droite sâ€™affiche le nombre de pairs/voisins symÃ©triques auxquels notre programme est connectÃ©. Au milieu, la plus grande partie de la fenÃªtre contient la liste des messages reÃ§us (stockÃ©e seulement en mÃ©moire). Pour discuter, câ€™est enfantin : il suffit dâ€™Ã©crire un message dans le champ de texte (en bas de la fenÃªtre) puis dâ€™appuyer sur EntrÃ©e pour lâ€™envoyer.

Lâ€™heure dâ€™envoi est spÃ©cifiÃ©e avant chaque message, ainsi que -- normalement -- le pseudo de lâ€™Ã©metteur. On a donc un affichage qui ressemble plus ou moins Ã  :

~~~
[14:26:44] <bob> mais câ€™est top !!
[14:26:55] <alice> comme tu dis ;-)
[14:27:02] <bob> au top
[14:27:06] <bob> miaou ğŸˆ
[14:27:18] <alice> wouf ğŸ•ğŸ•
[14:27:25] <bob> ...
~~~

 Des messages Ã  propos de lâ€™exÃ©cution du programme peuvent Ã©galement sâ€™afficher (en orange).

# Sous le capot

## ParticularitÃ©s du projet (tl;dr: protocole bien pensÃ© pour lâ€™usage)

On peut remercier lâ€™auteur du sujet dâ€™avoir rÃ©flÃ©chi sÃ©rieusement Ã  son protocole. La spÃ©cification y est relativement prÃ©cise, et des conseils sont mÃªmes fournis afin de nous guider dans lâ€™implÃ©mentation.

Il sâ€™agit dâ€˜un protocole pair Ã  pair dans lequels les messages sont Â« inondÃ©s Â» sur le rÃ©seau. Chaque membre du rÃ©seau reÃ§oit lâ€™intÃ©gralitÃ© des messages, quâ€™ils sâ€™adressent Ã  lui ou non. (Un membre, ou nÅ“ud, est un logiciel qui exÃ©cute une implÃ©mentation du protocole ; il forme un rÃ©seau avec lâ€™ensemble des autres membres avec qui il est Â« connectÃ© Â».)

Lorsquâ€™un message adressÃ© Ã  un rÃ©cepteur prÃ©cis est Ã©mis, ce message est transmis Ã  chacun des voisins de lâ€™Ã©metteur via __UDP__. De faÃ§on rÃ©cursive, chacun transmet Ã  son tour le message Ã  ses voisins jusquâ€™Ã  ce que tous les membres du rÃ©seau lâ€™aient finalement reÃ§u.

Une telle maniÃ¨re de procÃ©der induit Ã©videmment des limitations, et câ€™est pourquoi on se contente dâ€™utiliser ce protocole pour Ã©changer des messages textuels. Sans mÃªme parler de fragmentation, si un message/fichier lourd devait sâ€™Ã©changer entre deux utilisateurs, il se verrait copiÃ© par chacun des membres du rÃ©seau et cela constituerait un terrible gaspillage, notamment de bande passante.

Notre programme, dans sa partie rÃ©seau, sâ€™appuie exclusivement sur __UDP__ qui, comme vous le savez, est dÃ©pourvu de contrÃ´le dâ€™erreurs (rÃ©Ã©mission, fragmentation, etc.). Pour construire un vÃ©ritable groupe de discussion, il faut donc gÃ©rer tout un tas de choses (Â« Ã  qui est destinÃ© tel ou tel message ? Â» ; Â« qui est autorisÃ© Ã  mâ€™envoyer un message ? Â»).

Les donnÃ©es traitÃ©es par lâ€™application sont Ã©changÃ©es sous forme de __TLV__ (pour _Type, Length, Value_) dont les formats sont prÃ©cisÃ©ment dÃ©finis.

GrÃ¢ce Ã  un type de TLV particulier renvoyÃ© (rÃ©pondu) Ã  la rÃ©ception dâ€™un message, on sâ€™assure que le mÃªme message nâ€™est pas envoyÃ© plusieurs fois au mÃªme voisin.


## C pas sorcier (tl;dr: aÃ¯e câ€™est bas niveau)

Il Ã©tait imposÃ© dâ€™Ã©crire le programme en C. Chouette language. Pour de nombreuses raisons, il est fort adaptÃ© Ã  lâ€™apprentissage de la programmation rÃ©seau (on se trouve Ã  Â« bas niveau Â»).

Du point de vue de son architecture, notre programme est simple, il colle au protocole. Ceci dit, en C, puisquâ€™il faut notamment gÃ©rer la mÃ©moire, il est pratique de commencer par crÃ©er tout un tas de types de donnÃ©es, de routines, pour se simplifier la vie par la suite. Les concepts Ã  manipuler ont beau Ãªtre simples, la logique Ã©lÃ©mentaire, il nous a fallu Ã©crire plusieurs milliers de lignes de code ; lÃ  oÃ¹ une implÃ©mentation en Python (par exemple) aurait requis tout au plus quelques centaines de lignes.

Pas de souci avec Ã§a, hein, au contraire, Ã§a nous fait des choses Ã  dÃ©tailler dans ce compte rendu.

Mais tout de mÃªme : coder en C prend du temps.


## DÃ©cisions prises (tl;dr: interface avec GTK)

**miaouchat**, câ€™est le nom que nous avons donnÃ© Ã  notre logiciel.

Par contre, nous tenions Ã  avoir une vraie interface graphique, bien propre, afin que __miaouchat__ ne consiste pas seulement en une _proof of concept_ mais soit vraiment agrÃ©able Ã  utiliser pour des personnes qui nâ€™ont pas lâ€™habitude du terminal.

Câ€™est GTK qui nous a paru Ãªtre le meilleur choix, car GTK est une librairie...

- installÃ©e presque partout ;
- Ã©crite en C, et elle sâ€™utilise donc nativement dans ce langage ;
- Ã©prouvÃ©e (elle existe depuis plus de vingt ans) ; on dispose de suffisamment dâ€™exemples pour se dÃ©patouiller et obtenir ce que lâ€™on souhaite, contrairement Ã  beaucoup dâ€™autres solutions exotiques ;
- qui permet dâ€™obtenir un rÃ©sultat satisfaisant -- en terme dâ€™esthÃ©tique -- relativement simplement.


## Beaucoup de fichiers (tl;dr: câ€™est bien rangÃ©)

Fichier (.h/.c) | Contient | Notes
----------------|----------|------
dllist | fonctions de manipulation de listes doublement chaÃ®nÃ©es de type `dllist_t`. ||
interface |||
main | la fonction main() : câ€™est le chef dâ€™orchestre ||
map | sources de la hashmap. | merci Ã  lâ€™auteur : [rxi, sur Github](https://github.com/rxi/map) |
msg | mÃ©thodes de manipulation et transformations des TLV et messages. ||
msg_list |||
neighbour | implÃ©mentent les diffÃ©rentes listes de voisins et leur manipulations. ||
neighbour_map | implÃ©mentent les diffÃ©rentes listes de voisins et leur manipulations. ||
serialization |||
shared_resources |||
test | tests Ã©crits durant le dÃ©veloppement. | aucun intÃ©rÃªt. |
types | types non standards, afin de les centraliser et d'Ã©viter les conflits d'importation. ||
worker |||

# Logique de fonctionnement

Les diagrammes ci-dessous illustrent la logique de notre programme.

### Relation entre voisins

![](projet/img/voisins_dia.png)


## RÃ©ception dâ€™un message

![](projet/img/reception_data_dia.png)

~

VoilÃ .

Pour toute question, nous nous tenons Ã  votre disposition.

Merci dâ€™avoir lu.

FÃ©lix & Louis

<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
